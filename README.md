# Реализация MVVM в Unity

## Core 

### Game State Machine
Конечная стейт машина, которая управляет жизненным циклом проекта.
Реализует интерфейс IGameStateMachine, который реагламинтирует реализацию методов входа в состояния игры.
Кроме этого, внтури стейт машины на старте регистрируются все состояния, которые формируют жизненный цикл. 

### States 
Состояния игры, которые управляют жизнью проекта в определнный момент. Каждое состояние представляет собой класс, реализующий интерфейс семейства. 
Семейство интерфейсов, родителем которых является **IExitableState**, предоставляют точки входа/выхода в зависимости от нужд состояния.
В семейство входят следующие типы состояний: 
+ **IState** - базовое состояние, которое реализует простую точку входа: _OnEnter()_;
+ **IAsyncState** - асинхронное состояние, которое может выполняет загрузочные моменты, производит операции работы с облачными сервисами в асинхронном режиме работы: _OnEnterAsync()_;
+ **IPayloadState** - состояние с полезной нагрузкой, например загрузка сцены, по завершению которой необходимо выполнить инициализацию данных: _OnEnter(**TPayload**)_, _**TPayload**_ - обобщение без ограничений;
+ **ILinkState** - состояние, которое реализует шину данных через ссылки и обладает большим набором методов для реализации:
   * _IEnumerator Execute()_ - выполненине корутны ожиданя;
   * _void AddLink(ILink link)_ - привязка ссылки; 
   * _void RemoveLink(ILink link)_ - удаление ссылки; 
   * _void RemoveAllLinks()_ - удаление всех ссылок;
   * _bool ValidateLinks(out ILinkState nextState)_ - проверка ссылк на доступность; 
   * _void EnableLinks()_; 
   * _void DisableLinks()_;

---
### WindowFsm 

WindowFsm является стейт машиной по управлению окон на сцене.
Реализует интерфейсы: 
+ _**IWindowFsm**_ - регламентирует реализацию методов открытя и закрытия окон;
+ _**IWindowResolve**_ - регламентирует реализацию методов регистрации окон и их удаления из стейт машины.

#### IWindowFsm
1. Интерфейс регламинтирует реализацию следующих методов:
   + _void OpenWindow(**Type window, bool inHistory**)_. Аргумент _window_ - окно, которое необходимо открыть, аргумент _inHistory_ указывает на необходимость открытия окна с записью в историю или нет.
   + _void OpenWindow(**Type window**)_. Открывает окно без записи его в историю.
   + _void CloseWindow(**Type window**)_. Метод закрытия окна, не извлеченного из историю.
   + _void CloseWindow()_. Метод закрытия последнего окна в истории и открытии предыдущего, если такой имеется в истории.
   + _void ClearHistory()_. Очщает историю открытых окон и открывает последение окно в истории с добавлением его в начало.

2. События связи _Window_ с _WindowFsm_
При регистрации окна в WindowFsm, его необходимо связать с обработчиками событий. Для этого интерфейс IWindowFsm предлагает реализацию двух событий: 
   * _event Action\<Type\> **Opened**_
   * _event Action\<Type\> **Closed**_
   
При регистрации окна выполняются связывания: 
```c#
   window.Opened += OnOpened;
   window.Closed += OnClosed;
```
Напрямую связать обработчик события не получится, поэтому для этого стоит реализовать скрытый метод, который позволит это сделать: 
```c#
private void OnOpened(Type window) => Opened?.Invoke(window);
```

#### IWindowResolve
Интерфейс, который предоставляет методы регистрации и удаления.
+ _void Set\<TView\>() where TView : class, IView_ - регистрирует окно в стейт машине и связывает события открытия/закрытия окон: 
```c#
    window.Opened += OnOpened;
    window.Closed += OnClosed;
```
+ _void CleanUp()_ - очищает коллекцию зарегистрированных окон, выполня при этом отвязку событий: 
```c#
  foreach (IWindow window in _windows.Values)
  {
    window.Opened -= OnOpened;
    window.Closed -= OnClosed;
  }
```

#### Window
Реализует интерфейс _IWindow_, который регламентирует методы открытия закрытия, а так же события открытия/закрытия, который должны быть связаны с _WindowFsm_.
Является "оберткой" над компонентом _View_ в _MVVM_ и позволяет передать контроль над ним в **_WindowFsm_**.
---
### Элементы MVVM: Model, ViewModel, View

#### Model 
Модель инкапсулирует в себе данные и бизнес-логику управления этими данными. Общий интерфейс, который объединяет все модели - **IModel**. Данный интерфейс не обязателен для реализация. 

#### ViewModel
Реализуется путем наследования от абстрактного класса _AbstractViewModel_, который в свою очередь реализует интерфейс _IViewModel_. 
Интерфейс _IViewModel_ требует обязательно к реализаци два **event Action** и два **метода**: 
1. _**InvokedOpen**_ - событие на которое подписывается View и срабатывает, когда открывается окно;
2. _**InvokedClose**_ - событие на которое подписывается View и срабатывает, когда закрывается окно;
3. _**InvokeOpen**_ - метод, в котором производится подготовка данных перед открытием какого-либо представления, задействуя _WindowFsm_: 
```c#
public override void InvokeOpen()
{
  // Prepare data 
  _windowFsm.OpenWindow(typeof(FooView), true);  
}
```
4. _**InvokeClose**_ - метод, в котором производится подготовка данных перед закрытием какого-либо представления, задействуя _WindowFsm_.
```c#
public override void InvokeClose()
{
  // Prepare data 
  _windowFsm.CloseWindow(typeof(FooView));  
}
```
5. _**HandleOpenedWindow(Type uiWindow)**_ - вызывается при открытии окна, проверяе является ли представление целевым 
6. _**HandleClosedWindow(Type uiWindow)**_ - вызывается при закрытии окна, проверяе является ли представление целевым
```c#
protected virtual void HandleOpenedWindow(Type uiWindow)
{
    if(Window == uiWindow)
        InvokedOpen?.Invoke();
}
```

_AbstractViewModel_ дает базовые реализации методов взаимодействия с _IWindowFsm_, а так же реализует связь между _ViewModel_ и _Model_.
ViewModel не порождает наследников MonoBehaviour, даже через фабрики или пулы. Единственная задача VM - свзять модель и представления, предварительно подготовив данные из модели для отправки в представление.

#### View

Является наследников _MonoBehaviour_ и отвечает за отображение данных и регистрацию взаимодействий с пользователем. 
Обработки данных ввода или других любых данных не происходит в представлении. 
Представление, исходя из полученных данных, способна создать или взять из пула необходимые для ее работы объекты. 

_View_ представленно двумя абстрактными классами: **_AbstractView_** и **_AbstractPayloadView\<TViewModel\>()_**. 